// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProxy = `-- name: CreateProxy :exec
INSERT INTO proxies (id, listen_url, mode, path_key, condition, tags, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateProxyParams struct {
	ID        string
	ListenUrl string
	Mode      string
	PathKey   *string
	Condition []byte
	Tags      []string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) CreateProxy(ctx context.Context, arg *CreateProxyParams) error {
	_, err := q.db.Exec(ctx, createProxy,
		arg.ID,
		arg.ListenUrl,
		arg.Mode,
		arg.PathKey,
		arg.Condition,
		arg.Tags,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createProxyChange = `-- name: CreateProxyChange :exec
INSERT INTO proxy_changes (id, proxy_id, change_type, previous_state, new_state, created_at, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateProxyChangeParams struct {
	ID            string
	ProxyID       string
	ChangeType    string
	PreviousState []byte
	NewState      []byte
	CreatedAt     pgtype.Timestamptz
	CreatedBy     *string
}

func (q *Queries) CreateProxyChange(ctx context.Context, arg *CreateProxyChangeParams) error {
	_, err := q.db.Exec(ctx, createProxyChange,
		arg.ID,
		arg.ProxyID,
		arg.ChangeType,
		arg.PreviousState,
		arg.NewState,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	return err
}

const createTarget = `-- name: CreateTarget :exec
INSERT INTO targets (id, proxy_id, url, weight, is_active)
VALUES ($1, $2, $3, $4, $5)
`

type CreateTargetParams struct {
	ID       string
	ProxyID  string
	Url      string
	Weight   float64
	IsActive bool
}

func (q *Queries) CreateTarget(ctx context.Context, arg *CreateTargetParams) error {
	_, err := q.db.Exec(ctx, createTarget,
		arg.ID,
		arg.ProxyID,
		arg.Url,
		arg.Weight,
		arg.IsActive,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, email, password_hash, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateUserParams struct {
	ID           string
	Email        string
	PasswordHash string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createVisit = `-- name: CreateVisit :exec
INSERT INTO visits (id, proxy_id, target_id, user_id, rid, rrid, ruid, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateVisitParams struct {
	ID        string
	ProxyID   string
	TargetID  string
	UserID    string
	Rid       string
	Rrid      string
	Ruid      string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateVisit(ctx context.Context, arg *CreateVisitParams) error {
	_, err := q.db.Exec(ctx, createVisit,
		arg.ID,
		arg.ProxyID,
		arg.TargetID,
		arg.UserID,
		arg.Rid,
		arg.Rrid,
		arg.Ruid,
		arg.CreatedAt,
	)
	return err
}

const deleteTargetByProxyID = `-- name: DeleteTargetByProxyID :exec
DELETE
FROM targets
WHERE proxy_id = $1
`

func (q *Queries) DeleteTargetByProxyID(ctx context.Context, proxyID string) error {
	_, err := q.db.Exec(ctx, deleteTargetByProxyID, proxyID)
	return err
}

const getAllTags = `-- name: GetAllTags :many
SELECT DISTINCT UNNEST(tags)::text as tags
FROM proxies
WHERE tags IS NOT NULL
ORDER BY 1
`

func (q *Queries) GetAllTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tags string
		if err := rows.Scan(&tags); err != nil {
			return nil, err
		}
		items = append(items, tags)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProxies = `-- name: GetProxies :many
SELECT id, listen_url, mode, condition, tags, path_key
FROM proxies
ORDER BY created_at DESC
`

type GetProxiesRow struct {
	ID        string
	ListenUrl string
	Mode      string
	Condition []byte
	Tags      []string
	PathKey   *string
}

func (q *Queries) GetProxies(ctx context.Context) ([]*GetProxiesRow, error) {
	rows, err := q.db.Query(ctx, getProxies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProxiesRow
	for rows.Next() {
		var i GetProxiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ListenUrl,
			&i.Mode,
			&i.Condition,
			&i.Tags,
			&i.PathKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProxiesByTags = `-- name: GetProxiesByTags :many
SELECT DISTINCT p.id,
                p.listen_url,
                p.mode,
                p.condition,
                p.tags,
                p.path_key,
                p.created_at,
                p.updated_at
FROM proxies p
WHERE tags @> $1
ORDER BY p.created_at DESC
`

type GetProxiesByTagsRow struct {
	ID        string
	ListenUrl string
	Mode      string
	Condition []byte
	Tags      []string
	PathKey   *string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) GetProxiesByTags(ctx context.Context, tags []string) ([]*GetProxiesByTagsRow, error) {
	rows, err := q.db.Query(ctx, getProxiesByTags, tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProxiesByTagsRow
	for rows.Next() {
		var i GetProxiesByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ListenUrl,
			&i.Mode,
			&i.Condition,
			&i.Tags,
			&i.PathKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProxy = `-- name: GetProxy :one
SELECT id, listen_url, mode, condition, path_key, created_at, updated_at
FROM proxies
WHERE id = $1
`

type GetProxyRow struct {
	ID        string
	ListenUrl string
	Mode      string
	Condition []byte
	PathKey   *string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) GetProxy(ctx context.Context, id string) (*GetProxyRow, error) {
	row := q.db.QueryRow(ctx, getProxy, id)
	var i GetProxyRow
	err := row.Scan(
		&i.ID,
		&i.ListenUrl,
		&i.Mode,
		&i.Condition,
		&i.PathKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProxyChangesByProxyID = `-- name: GetProxyChangesByProxyID :many
SELECT id, proxy_id, change_type, previous_state, new_state, created_at, created_by
FROM proxy_changes
WHERE proxy_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProxyChangesByProxyIDParams struct {
	ProxyID string
	Limit   int32
	Offset  int32
}

func (q *Queries) GetProxyChangesByProxyID(ctx context.Context, arg *GetProxyChangesByProxyIDParams) ([]*ProxyChange, error) {
	rows, err := q.db.Query(ctx, getProxyChangesByProxyID, arg.ProxyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProxyChange
	for rows.Next() {
		var i ProxyChange
		if err := rows.Scan(
			&i.ID,
			&i.ProxyID,
			&i.ChangeType,
			&i.PreviousState,
			&i.NewState,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProxyTags = `-- name: GetProxyTags :one
SELECT tags
FROM proxies
WHERE id = $1
`

func (q *Queries) GetProxyTags(ctx context.Context, id string) ([]string, error) {
	row := q.db.QueryRow(ctx, getProxyTags, id)
	var tags []string
	err := row.Scan(&tags)
	return tags, err
}

const getStats = `-- name: GetStats :one
SELECT COALESCE(SUM(request_count), 0)::int as requests,
       COALESCE(SUM(error_count), 0)::int   as errors
FROM proxy_stats
WHERE timestamp BETWEEN to_timestamp($1::text, 'YYYY-MM-DD HH24:MI:SS.MS')
          AND to_timestamp($2::text, 'YYYY-MM-DD HH24:MI:SS.MS')
`

type GetStatsParams struct {
	FromTime string
	ToTime   string
}

type GetStatsRow struct {
	Requests int32
	Errors   int32
}

func (q *Queries) GetStats(ctx context.Context, arg *GetStatsParams) (*GetStatsRow, error) {
	row := q.db.QueryRow(ctx, getStats, arg.FromTime, arg.ToTime)
	var i GetStatsRow
	err := row.Scan(&i.Requests, &i.Errors)
	return &i, err
}

const getTargetStats = `-- name: GetTargetStats :many
SELECT target_id,
       timestamp,
       request_count as requests,
       error_count   as errors,
       jsonb_array_length(unique_users) as users_count
FROM proxy_stats
WHERE proxy_id = $1
  AND timestamp BETWEEN to_timestamp($2::text, 'YYYY-MM-DD HH24:MI:SS.MS')
    AND to_timestamp($3::text, 'YYYY-MM-DD HH24:MI:SS.MS')
`

type GetTargetStatsParams struct {
	ProxyID  string
	FromTime string
	ToTime   string
}

type GetTargetStatsRow struct {
	TargetID   string
	Timestamp  pgtype.Timestamp
	Requests   int32
	Errors     int32
	UsersCount int32
}

func (q *Queries) GetTargetStats(ctx context.Context, arg *GetTargetStatsParams) ([]*GetTargetStatsRow, error) {
	rows, err := q.db.Query(ctx, getTargetStats, arg.ProxyID, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTargetStatsRow
	for rows.Next() {
		var i GetTargetStatsRow
		if err := rows.Scan(
			&i.TargetID,
			&i.Timestamp,
			&i.Requests,
			&i.Errors,
			&i.UsersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTargetsByProxyID = `-- name: GetTargetsByProxyID :many
SELECT id, url, weight, is_active
FROM targets
WHERE proxy_id = $1
`

type GetTargetsByProxyIDRow struct {
	ID       string
	Url      string
	Weight   float64
	IsActive bool
}

func (q *Queries) GetTargetsByProxyID(ctx context.Context, proxyID string) ([]*GetTargetsByProxyIDRow, error) {
	rows, err := q.db.Query(ctx, getTargetsByProxyID, proxyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTargetsByProxyIDRow
	for rows.Next() {
		var i GetTargetsByProxyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Weight,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueUsersCount = `-- name: GetUniqueUsersCount :one
SELECT COUNT(DISTINCT users)
FROM proxy_stats,
     LATERAL jsonb_array_elements_text(unique_users) AS users
WHERE timestamp BETWEEN to_timestamp($1::text, 'YYYY-MM-DD HH24:MI:SS.MS')
          AND to_timestamp($2::text, 'YYYY-MM-DD HH24:MI:SS.MS')
`

type GetUniqueUsersCountParams struct {
	FromTime string
	ToTime   string
}

func (q *Queries) GetUniqueUsersCount(ctx context.Context, arg *GetUniqueUsersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUniqueUsersCount, arg.FromTime, arg.ToTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, created_at, updated_at
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateProxyCondition = `-- name: UpdateProxyCondition :exec
UPDATE proxies
SET condition  = $1,
    updated_at = $2
WHERE id = $3
`

type UpdateProxyConditionParams struct {
	Condition []byte
	UpdatedAt pgtype.Timestamptz
	ID        string
}

func (q *Queries) UpdateProxyCondition(ctx context.Context, arg *UpdateProxyConditionParams) error {
	_, err := q.db.Exec(ctx, updateProxyCondition, arg.Condition, arg.UpdatedAt, arg.ID)
	return err
}

const updateProxyTags = `-- name: UpdateProxyTags :exec
UPDATE proxies
SET tags       = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateProxyTagsParams struct {
	Tags []string
	ID   string
}

func (q *Queries) UpdateProxyTags(ctx context.Context, arg *UpdateProxyTagsParams) error {
	_, err := q.db.Exec(ctx, updateProxyTags, arg.Tags, arg.ID)
	return err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)
`

func (q *Queries) UserExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, userExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
